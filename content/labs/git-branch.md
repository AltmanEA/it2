---
title: "6. Ветки в GIT"
weight: 20
---

## Теоретические сведения

### Ветки и указатели на коммиты

При работе над проектами часто возникает ситуация при которой существует несколько вариантов проекта. Например, один вариант – это текущая версия проекта, другой вариант – это версия, в которую внесены экспериментальные или логически не завершенные элементы. Особенно часто возникают различные варианты проекта при работе над ним нескольких разработчиков.

В СКВ различные варианты проекта хранятся в различных **ветках** (branch). 

При создании проекта существует только одна ветка (один вариант проекта), которая называется ```master```. Эта ветка в течении всего проекта является основной. На ее основе могут создавать другие ветки, которые с помощью новых коммитов будут представлять другие варианты проекта.

Ветки проекта могут объединяться (сливаться). Например, после логического завершения какой-либо части проекта, выполняемой в отдельной ветке, ветка этой части сливается с веткой ```master```.

В СКВ git для организации работы с ветками каждый коммит хранит указатель на предыдущий коммит. Благодаря этому для каждой ветки достаточно хранить только указатель на последний коммит в этой ветке. Указатель на ветку имеет то же имя, что и ветка, и в этом смысле указатель и саму ветку можно считать синонимами.

Помимо указателей на ветку в git существует еще указатель ```HEAD``` на текущий коммит (ветку). В случае, если используется одна ветка, указатели ```HEAD``` и ```master``` совпадают. Если в репозитории имеется несколько веток, то ветка, на которую указывает указатель ```HEAD``` называется текущей.

При выполнении команды ```git commit``` создается новый коммит, после чего на него перемещаются указатели ```HEAD``` и текущей ветки.

### Команды для работы с ветками и указателями

Основные команды для работы с ветками схематично приведены на рисунке 2 (с1, с2, с3 – коммиты, стрелки между блоками – указатели).

<center>
<img src="../images/commits.png" width=50%>

Рисунок 2 – Команды для работы с ветками

</center>

Для создания новой ветки используется команда 

<pre>
git branch <i>имя_ветки</i>
</pre>

Для просмотра имеющихся в репозитории веток нужно ввести эту команду без аргументов:

<pre>
git branch
</pre>

Эта команда только создает ветку, но не изменяет указатель на текущую ветку ```HEAD```. Для того, чтобы сделать ветку текущей (переместить ```HEAD```) нужно выполнить команду

<pre>
git checkout <i>имя_ветки</i>
</pre>

Создать ветку и сразу на нее переключиться можно с помощью команды

<pre>
git checkout -b <i>имя_ветки</i>
</pre>

В обычном режиме работы рассмотренных команд достаточно для работы с ветками (за исключением слияния веток, которое будет рассмотрено отдельно). Однако, для исправления ошибок при работе с коммитами может потребоваться команда, позволяющая вручную перемещать указатели веток с коммита на коммит (прежде всего, откатывать указатели ветки на предыдущие коммиты).

Для перемещения указателей веток может использоваться команда 

<pre>
git reset [<i>режим</i>] <i>commit</i>
</pre>

В поле *commit* задается идентификатор коммита. Идентификатор представляет собой шестнадцатеричное число, получаемое из контрольной суммы. Узнать идентификаторы коммитов можно с помощью команды ```git log```. Также в поле *commit* можно использовать специальные мнемокоды, например, ```HEAD~``` будет указывать на предыдущий коммит текущей ветки. 

В общем случае эта команда делает следующие действия:

1. Перемещает ветку, на которую указывает ```HEAD``` на заданный *commit*.
2. Обновляет индекс в соответствии с содержимым коммита *commit*.
3. Обновляет содержимое рабочего каталога в соответствии с содержимым коммита *commit*.

В различных сценариях использования может потребоваться выполнять не полный набора этих действий, что задается *режимом* команды:

- ```--soft``` – выполняет только первое действие;
- ```--mixed``` (режим по-умолчанию) – выполняет 1 и 2 действия;
- ```--hard``` – выполняет все действия.

Существует также версия команды ```git reset``` для обновления индекса (без перемещение указателей). Она была рассмотрена в предыдущей работе.

Помимо команд для выполнения действий над ветками СКВ git имеет возможности для их просмотра. По-умолчанию, команда ```git log``` выводит коммиты только текущей ветки. Для просмотра всех веток для этой команды нужно указать ключи ```-all```. Более наглядным вывод веток в терминал получится, если дополнительно указать ключ ```--graph```, при котором с помощью псевдографики будет нарисовано дерево репозитория.

## Задание к работе

После каждого пункта из задания к работе нужно выполнить команду для вывода в терминал дерева репозитория. В отчете нужно также привести содержимое файла репозитория после выполнение каждого пункта, начиная со 2.

1. Создайте ветку, назовите ее своим именем (в транслитерации). 
2. Измените содержимое файла и добавьте коммит в новую ветку. Повторите этот пункт.
3. Измените содержимое файла и добавьте коммит в ветку ```master```. Повторите этот пункт.
4. Установите указатель новой ветки на коммит с первым изменением файла.
5. Установите указатель ветки ```master``` на коммит с первым изменением файла в этой ветки. При этом должно произойти обновление индекса в соответствии с содержимым этого коммита. Для просмотра содержимого индекса используйте команду ```git ls-files```.
6. Перейдите на новую ветку и переместите ее указатель на первоначальный коммит в этой работе. При этом должно произойти обновление индекса и рабочего каталога в соответствии с содержимым этого коммита.
